Proper Database Connection Management

// FILE: database/database.go
package database

import (
	"fmt"
	"log"
	"os"
	"time"

	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

type DbInstance struct {
	Db *gorm.DB
}

var Database DbInstance

func ConnectDb() {
	dsn := fmt.Sprintf(
		"host=%s user=%s password=%s dbname=%s port=%s sslmode=disable TimeZone=Asia/Dhaka",
		os.Getenv("DB_HOST"),
		os.Getenv("DB_USER"),
		os.Getenv("DB_PASSWORD"),
		os.Getenv("DB_NAME"),
		os.Getenv("DB_PORT"),
	)

	db, err := gorm.Open(postgres.New(postgres.Config{
		DSN:                  dsn,
		PreferSimpleProtocol: true, // Disable prepared statements cache
	}), &gorm.Config{
		Logger:      logger.Default.LogMode(logger.Info),
		PrepareStmt: false, // Disable prepared statement
	})

	if err != nil {
		log.Fatal("Failed to connect to database. \n", err)
	}

	log.Println("Connected to database successfully")

	// Get the underlying SQL database
	sqlDB, err := db.DB()
	if err != nil {
		log.Fatal("Failed to get database instance. \n", err)
	}

	// Configure connection pool
	// SetMaxIdleConns sets the maximum number of connections in the idle connection pool
	sqlDB.SetMaxIdleConns(10)

	// SetMaxOpenConns sets the maximum number of open connections to the database
	sqlDB.SetMaxOpenConns(100)

	// SetConnMaxLifetime sets the maximum amount of time a connection may be reused
	sqlDB.SetConnMaxLifetime(time.Hour)

	// SetConnMaxIdleTime sets the maximum amount of time a connection may be idle
	sqlDB.SetConnMaxIdleTime(10 * time.Minute)

	// Verify connection
	if err := sqlDB.Ping(); err != nil {
		log.Fatal("Failed to ping database. \n", err)
	}

	log.Println("Database connection pool configured successfully")

	Database = DbInstance{
		Db: db,
	}
}

// CloseDb closes the database connection
func CloseDb() error {
	sqlDB, err := Database.Db.DB()
	if err != nil {
		return err
	}
	return sqlDB.Close()
}

// GetDB returns the database instance (useful for testing or manual access)
func GetDB() *gorm.DB {
	return Database.Db
}


// FILE: main.go
package main

import (
	"log"
	"os"
	"os/signal"
	"syscall"

	"github.com/ayonqfl/go-fiber-gorm/database"
	"github.com/ayonqfl/go-fiber-gorm/middleware"
	"github.com/ayonqfl/go-fiber-gorm/routes"
	"github.com/gofiber/fiber/v2"
	"github.com/joho/godotenv"
)

func Welcome(c *fiber.Ctx) error {
	return c.SendString("Welcome to OMS API's")
}

func setupRoutes(app *fiber.App) {
	// Define the Welcome routes
	app.Get("/api", Welcome)

	// Apply authentication middleware for protected routes
	protected := app.Use(middleware.AuthMiddleware())

	// Define the User routes
	routes.UserHandlers(protected.Group("/api/users"))
}

func main() {
	// Load environment variables
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
	}

	// Connect to database
	database.ConnectDb()

	// Defer database connection close
	defer func() {
		if err := database.CloseDb(); err != nil {
			log.Printf("Error closing database connection: %v", err)
		} else {
			log.Println("Database connection closed successfully")
		}
	}()

	// Create Fiber app
	app := fiber.New(fiber.Config{
		AppName: "qTrader OMS API",
		// Add graceful shutdown
		DisableStartupMessage: false,
	})

	// Setup routes
	setupRoutes(app)

	// Channel to listen for interrupt signals
	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt, syscall.SIGTERM)

	// Start server in a goroutine
	go func() {
		if err := app.Listen(":9000"); err != nil {
			log.Fatalf("Error starting server: %v", err)
		}
	}()

	log.Println("Server started on :9000")

	// Wait for interrupt signal
	<-c
	log.Println("Shutting down gracefully...")

	// Shutdown the server
	if err := app.Shutdown(); err != nil {
		log.Fatalf("Error during shutdown: %v", err)
	}

	log.Println("Server shutdown complete")
}



// ---- helpers/authentication: bellow this all functions are user handlers ----
// GetUserFromContext retrieves user data from context
func GetUserFromContext(c *fiber.Ctx) *TokenData {
	user := c.Locals("user")
	if user == nil {
		return nil
	}
	userData, ok := user.(*TokenData)
	if !ok {
		return nil
	}
	return userData
}

// GetUserIDFromContext retrieves user_id from context as string
func GetUserIDFromContext(c *fiber.Ctx) string {
	userID := c.Locals("user_id")
	if userID == nil {
		return ""
	}
	userIDStr, ok := userID.(string)
	if !ok {
		return ""
	}
	return userIDStr
}

// GetUsernameFromContext retrieves username from context
func GetUsernameFromContext(c *fiber.Ctx) string {
	username := c.Locals("username")
	if username == nil {
		return ""
	}
	usernameStr, ok := username.(string)
	if !ok {
		return ""
	}
	return usernameStr
}

// GetUserRoleFromContext retrieves user role from context
func GetUserRoleFromContext(c *fiber.Ctx) string {
	role := c.Locals("users_roles")
	if role == nil {
		return ""
	}
	roleStr, ok := role.(string)
	if !ok {
		return ""
	}
	return roleStr
}

// GetClientCodeFromContext retrieves client code from context
func GetClientCodeFromContext(c *fiber.Ctx) string {
	clientCode := c.Locals("client_code")
	if clientCode == nil {
		return ""
	}
	clientCodeStr, ok := clientCode.(string)
	if !ok {
		return ""
	}
	return clientCodeStr
}

// GetUserIDIntFromContext retrieves user id (int) from context
func GetUserIDIntFromContext(c *fiber.Ctx) int {
	id := c.Locals("id")
	if id == nil {
		return 0
	}
	idInt, ok := id.(int)
	if !ok {
		return 0
	}
	return idInt
}


-- token validation debug code ---
// // Debug expiration start
// log.Infof("=== Token Expiration Debug ===")
// log.Infof("Token ExpiresAt: %v", claims.ExpiresAt)
// if claims.ExpiresAt != nil {
// 	log.Infof("Expiration Time: %v", claims.ExpiresAt.Time)
// 	log.Infof("Current Time: %v", time.Now())
// 	log.Infof("Time Until Expiry: %v", time.Until(claims.ExpiresAt.Time))
// 	log.Infof("Is Expired: %v", claims.ExpiresAt.Before(time.Now()))
// } else {
// 	log.Warn("WARNING: Token has no expiration time!")
// }
// // Debug expiration end